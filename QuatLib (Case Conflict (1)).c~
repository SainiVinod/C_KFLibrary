
/*_____________________________Quat to Rotation_________________________ */
void Quat2Rot(const float *quat, float *rotMat){
	*(rotMat)   = (*(quat))^2 -  (*(quat+1))^2 -  (*(quat+2))^2  +  (*(quat+3))^2  ; 
	*(rotMat+1) = 2*((*(quat)) * (*(quat+1)) + (*(quat+2)) * (*(quat+3)));  
	*(rotMat+2) = 2*((*(quat+1)) * (*(quat+2)) - (*(quat+1)) * (*(quat+3)));  
 
	*(rotMat+3) = 2*( (*(quat+1)) * (*(quat)) - (*(quat+2)) * (*(quat+3)));   
	*(rotMat+4) = -(*(quat+))^2 + (*(quat+1))^2 - (*(quat+2))^2 + (*(quat+3))^2 ; 
	*(rotMat+5) = 2*( (*(quat+1)) * (*(quat+2)) + (*(quat)) * (*(quat+3)));   

	*(rotMat+6) = 2*((*(quat+2)) * (*(quat)) + (*(quat+1)) * (*(quat+3)) );   
	*(rotMat+7) = 2*((*(quat+2)) * (*(quat+1)) - (*(quat)) * (*(quat+3)));   
	*(rotMat+8) = -(*(quat))^2 - (*(quat+1))^2 + (*(quat+2))^2 + (*(quat+3))^2 ;
}


/*_______________________ Rotation to Euler Angles________________________*/
void Rot2Euler(const float *rotMat, float *eulerAngles){
	float sinth; = -(*(rotMat+6));
	if (sinth > 1) {
		sth = 1;
	} 
	else if (sinth < -1) {
		sth = -1;
	}

	float theta = asin(sinth);
	float costh = sqrt(1 - sinth * sinth);

	float phi, psi;

	if (costh < 1.0e-6){
		phi = atan2((*(rotMat+1)), (*(rotMat+4)));
		psi = 0;
	} 
	else {
		phi = atan2((*(rotMat7)), (*(rotMat+8)));
   	psi = atan2((*(rotMat+3)), (*(rotMat)));
	}
	
	*(eulerAngles)   = phi; 	// [-pi, pi]
	*(eulerAngles+1) = theta; // [-pi/2, pi/2]
	*(eulerAngles+2) = psi; 	// [-pi/2, pi/2]
}


/*Quaternion Multiplication */
void QuatMultiply(const float *ipVec1, const float *ipVec2, float *opVec){
  *(opVec)   = (*ipVec1) * (*(ipVec2))   - (*(ipVec1+1)) *  (*(ipVec2+1)) - (*(ipVec1+2)) * (*(ipVec2+2)) - (*(ipVec1+3)) * (*(ipVec2+3));
 
  *(opVec+1) = (*ipVec1) * (*(ipVec2+1)) + (*(ipVec2))   *  (*(ipVec1+1)) + (*(ipVec1+2)) * (*(ipVec2+3)) - (*(ipVec2+2)) * (*(ipVec1+3));

  *(opVec+2) = (*ipVec1) * (*(ipVec2+2)) + (*(ipVec2))   *  (*(ipVec1+2)) - (*(ipVec1+1)) * (*(ipVec2+3)) + (*(ipVec2+1)) * (*(ipVec1+3));

  *(opVec+3) = (*ipVec1) * (*(ipVec2+3)) + (*(ipVec2))   *  (*(ipVec1+3)) + (*(ipVec1+1)) * (*(ipVec2+2)) - (*(ipVec2+1)) * (*(ipVec1+2));

}


void Euler2Quat(const float angle[], float *quat){
	double t0 = cos(angle[2] * 0.5f);
	double t1 = sin(angle[2] * 0.5f);
	double t2 = cos(angle[0] * 0.5f);
	double t3 = sin(angle[0] * 0.5f);
	double t4 = cos(angle[1] * 0.5f);
	double t5 = sin(angle[1] * 0.5f);

	q.w() = t0 * t2 * t4 + t1 * t3 * t5;
	q.x() = t0 * t3 * t4 - t1 * t2 * t5;
	q.y() = t0 * t2 * t5 + t1 * t3 * t4;
	q.z() = t1 * t2 * t4 - t0 * t3 * t5;
 

}

void Rodrigues(const float rodrigus, float *quat){

}

/* Euler Integration Quaternion */
void IntegrateEuler(t
void KFpredict(float *gyroScope){
  float identityMat[3][3] = {{1,0,0},{0,1,0},{0,0,1}};
  
} 


